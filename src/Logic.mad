import {} from "List"
import { floor, mod } from "Math"
import { floatToInteger, integerToFloat } from "Number"



/**
 * This is the core logic for the "perturb" function used in the LCG
 * It is fundamentally applying (b * n + a) % d
 * @since 0.0.1
 */
perturbation :: Integer -> Integer -> Integer -> Integer -> Integer
export perturbation = (n, b, a, d) => pipe(
  map(integerToFloat),
  where {
    [b2, n2, a2] =>
      floatToInteger(b2 * n2 + a2)

    _ =>
      0
  },
  mod($, d),
)([b, n, a])

/**
 * Clamp a number between two boundaries, modularly
 * @since 0.0.1
 * @example
 * modClamp(5, 10, 100)
 */
modClamp :: Integer -> Integer -> Integer -> Integer
export modClamp = (min, max, x) => {
  y = mod(x, max - min)
  return y < min ? y + max : y
}


/**
 * Get a value between two boundaries, low and high.
 * Here the floating value is being used as a multiplier and this function is pure.
 * But upstream this function is used within a PRNG and the supplied floating value changes
 * on each generation.
 * @since 0.0.1
 * @example
 * intGradient(1, 100, 0.5)
 */
intGradient :: Integer -> Integer -> Float -> Integer
export intGradient = (low, high, f) => pipe(
  floor,
  floatToInteger,
)((integerToFloat(high) - integerToFloat(low) + 1.0) * f + integerToFloat(low))
