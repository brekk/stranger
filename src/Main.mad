// import Wish from "Wish"
import type { Seed } from "./Types"

import IO from "IO"
import List from "List"
import { Just, Nothing } from "Maybe"
import Number from "Number"
import String from "String"
import Wish from "Wish"

import LCG from "./LCG"
import PRNG from "./PRNG"
import { stringToInt, stringToIntJS } from "./String"



runLCG = (key, seedNumber, fn) => pipe(
  LCG.mkSeed,
  fn,
  IO.trace(`LCG ${key}`),
)(seedNumber)

// run :: Inspect Seed => String -> Integer -> (Wish a Seed -> Wish a {}) -> {}
run = (key, seedNumber, fn) => pipe(
  PRNG.create,
  map(IO.trace(`run ${key} -->`)),
  fn,
  Wish.fulfill((a) => { IO.trace("bad " ++ key, a) }, (b) => { IO.trace("good " ++ key, b) }),
)(seedNumber)

main = () => {
  runLCG(
    "START",
    100,
    pipe(
      LCG.iterateWithProof(10, LCG.deriveInt(1, 10)),
    ),
  )
  IO.trace("yo", PRNG.create(stringToInt("shit")))
  IO.trace(
    "YO",
    pipe(
      LCG.mkSeed,
      LCG.iterateWithProof(10, LCG.deriveFloat),
      LCG.dropProof,
    )(100),
  )
  run("A", 100, map(LCG.deriveFloat))
  run(
    "B",
    100,
    pipe(
      PRNG.step,
      PRNG.step,
      PRNG.step,
      PRNG.step,
      map(LCG.deriveFloat),
    ),
  )
  runLCG(
    "LCG :: B",
    100,
    pipe(
      LCG.next,
      LCG.next,
      LCG.next,
      LCG.next,
      LCG.deriveFloat,
    ),
  )
  run(
    "C",
    100,
    pipe(
      PRNG.stepN(4),
      map(LCG.deriveFloat),
    ),
  )
  run("D", 100, PRNG.stepN(4))
  run(
    "E",
    100,
    map(
      pipe(
        LCG.iterateWithProof(4, LCG.deriveFloat),
        LCG.dropProof,
      ),
    ),
  )
  run(
    "INTEGER (step 4)",
    100,
    pipe(
      PRNG.stepN(4),
      map(LCG.deriveInt(0, 100)),
    ),
  )
  run(
    "INTEGERS",
    100,
    map(
      pipe(
        LCG.iterateWithProof(10, LCG.deriveInt(0, 100)),
        LCG.dropProof,
      ),
    ),
  )

  run(
    "booleans",
    100,
    pipe(
      map(LCG.iterate(10, LCG.deriveBool)),
    ),
  )
  runLCG(
    "pick!",
    100,
    pipe(
      LCG.iterateWithProof(
        100,
        pipe(
          LCG.deriveChoice(['a', 'b', 'c', 'd', 'e', 'f']),
          where {
            Just(x) =>
              x

            Nothing =>
              'x'
          },
        ),
      ),
      LCG.dropProof,
    ),
  )
  runLCG(
    "iterate!",
    100,
    pipe(
      LCG.iterate(10, LCG.deriveChoice(['x', 'y', 'z'])),
    ),
  )
  ALPHABET = String.split("", "abcdefghijklmnopqrstuvwxyz")
  // shuffle sucks in LCG.iterate
  runLCG(
    "iterate single shuffle!",
    100,
    pipe(
      LCG.iterate(
        10,
        pipe(
          LCG.deriveSingleShuffle(ALPHABET),
          .stack,
        ),
      ),
    ),
  )
  runLCG(
    "iterateBinary single shuffle!",
    100,
    pipe(
      LCG.iterateBinary(
        10,
        (a, b) => pipe(
          LCG.deriveSingleShuffle(a),
          .stack,
        )(b),
        ALPHABET,
      ),
    ),
  )
  runLCG(
    "iterateBinary shuffle!",
    100,
    pipe(
      LCG.iterateBinary(10, LCG.deriveShuffle, ALPHABET),
    ),
  )
  IO.trace("mutation?", ALPHABET)
}
