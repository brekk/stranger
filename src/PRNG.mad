import type { Maybe } from "Maybe"

import type { Async, Seed } from "./Types"

import IO from "IO"
import List from "List"
import { Just, Nothing } from "Maybe"
import Tuple from "Tuple"

import { LCG_M } from "./Constants"
import LCG from "./LCG"
import { boundedInt } from "./Logic"



create :: Integer -> Async Seed
export create = pipe(
  LCG.mkSeed,
  of,
)

step :: Async Seed -> Async Seed
export step = map(LCG.next)

stepN :: Integer -> Async Seed -> Async Seed
export stepN = (steps, mSeed) => pipe(
  List.range(0),
  List.reduce((prev, _) => step(prev), mSeed),
)(steps)

alias SeededTuple a = #[Seed, a]

seedTuple :: Seed -> a -> SeededTuple a
export seedTuple = (seed, a) => #[seed, a]

mapStep :: (Seed -> a) -> Seed -> SeededTuple a
export mapStep = (fn, seed) => #[LCG.next(seed), fn(seed)]

mapSteps :: Integer -> (Seed -> a) -> Async Seed -> Async (List (SeededTuple a))
export mapSteps = (steps, fn, mSeed) => map(
  (seed) => pipe(
    List.range(0),
    List.reduce(
      (agg, _) => pipe(
        mapStep(fn),
        where {
          #[newSeed, x] =>
            ({ prev: newSeed, stack: [...agg.stack, #[newSeed, x]] })
        },
      )(agg.prev),
      { stack: [], prev: seed },
    ),
    .stack,
  )(steps + 1),
  mSeed,
)

dropSeeds :: List (SeededTuple a) -> List a
export dropSeeds = map(Tuple.snd)

floatFromSeed :: Seed -> Float
export floatFromSeed = pipe(
  LCG.next,
  LCG.unSeed,
  (x) => (x / LCG_M),
)

randomInt :: Integer -> Integer -> Seed -> Integer
export randomInt = (low, high, seed) => pipe(
  floatFromSeed,
  boundedInt(low, high),
)(seed)

randomBool :: Seed -> Boolean
export randomBool = pipe(
  floatFromSeed,
  (f) => f > 0.5,
)

randomPick :: List a -> Seed -> Maybe a
export randomPick = (list, seed) => pipe(
  List.nth(randomInt(0, List.length(list) - 1, seed)),
)(list)

setIndex :: Integer -> a -> List a -> List a
export setIndex = (n, val, list) => List.mapWithIndex((x, i) => i == n ? val : x, list)

maybeSetIndex :: Integer -> Maybe a -> List a -> List a
export maybeSetIndex = (n, mV, list) => where(mV) {
  Just(x) =>
    setIndex(n, x, list)

  Nothing =>
    list
}

randomShuffle :: List a -> Seed -> List a
export randomShuffle = (list, seed) => pipe(
  List.reduce(
    (agg, _) => {
      max = List.length(list) - 1
      x = randomInt(1, max, agg.current)
      next = LCG.next(agg.current)
      y = randomInt(1, max, next)
      fromStack = List.nth($, agg.stack)
      nthX = fromStack(x)
      nthY = fromStack(y)
      return {
        stack: pipe(
          maybeSetIndex(y, nthX),
          maybeSetIndex(x, nthY),
        )(agg.stack),
        current: next,
      }
    },
    { stack: list, current: seed },
  ),
  .stack,
)(list)
