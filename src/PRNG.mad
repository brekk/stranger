import type { Maybe } from "Maybe"
import type { Wish } from "Wish"

import type { Seed, SeededTuple } from "./Types"

import List from "List"
import Tuple from "Tuple"

import { LCG_M } from "./Constants"
import LCG from "./LCG"
import { maybeSetIndex } from "./List"
import { intGradient } from "./Logic"



/**
 * Create a seed from an integer and wrap it in a Wish
 * @since 0.0.1
 * @example
 * PRNG.create(100)
 */
create :: Integer -> Wish a Seed
export create = pipe(
  LCG.mkSeed,
  of,
)

/**
 * Step a given PRNG one generation forward
 * @since 0.0.1
 * @example
 * pipe(
 *   PRNG.create,
 *   PRNG.step
 * )(100)
 */
step :: Wish a Seed -> Wish a Seed
export step = (mSeed) => map(LCG.next)(mSeed)

/**
 * Step a given PRNG multiple generations forward
 * @since 0.0.1
 * @example
 * pipe(
 *   PRNG.create,
 *   PRNG.stepN(10)
 * )(100)
 */
stepN :: Integer -> Wish a Seed -> Wish a Seed
export stepN = (steps, mSeed) => pipe(
  List.range(0),
  List.reduce((prev, _) => step(prev), mSeed),
)(steps)

/**
 * Simple wrapper function to create a SeededTuple
 * @since 0.0.1
 * @example
 * PRNG.seedTuple(LCG.mkSeed(100), "hey there")
 */
seedTuple :: Seed -> a -> SeededTuple a
export seedTuple = (seed, a) => #[seed, a]

/**
 * Apply a transformation function to a given seed and set the next seed in a step
 * @since 0.0.1
 * @example
 * PRNG.mapStep(PRNG.randomBool, LCG.mkSeed(100))
 */
mapStep :: (Seed -> a) -> Seed -> SeededTuple a
export mapStep = (fn, seed) => #[LCG.next(seed), fn(seed)]

/**
 * Apply mapStep multiple times in a row
 * @since 0.0.1
 * @example
 * PRNG.mapSteps(10, PRNG.randomBool, PRNG.create(100))
 */
mapSteps :: Integer -> (Seed -> a) -> Wish a Seed -> Wish a (List (SeededTuple a))
export mapSteps = (steps, fn, mSeed) => map(
  (seed) => pipe(
    List.range(0),
    List.reduce(
      (agg, _) => pipe(
        mapStep(fn),
        where {
          #[newSeed, x] =>
            ({ prev: newSeed, stack: [...agg.stack, #[newSeed, x]] })
        },
      )(agg.prev),
      { stack: [], prev: seed },
    ),
    .stack,
  )(steps + 1),
  mSeed,
)

/**
 * Convert a list of SeededTuples into just a list
 * @since 0.0.1
 * @example
 * pipe(
 *   PRNG.create,
 *   PRNG.mapSteps(10, PRNG.randomBool),
 *   PRNG.dropSeeds
 * )(100)
 */
dropSeeds :: List (SeededTuple a) -> List a
export dropSeeds = (list) => map(Tuple.snd, list)

/**
 * Get a floating value from a seed
 * @since 0.0.1
 * @example
 * PRNG.floatFromSeed(PRNG.create(100))
 */
floatFromSeed :: Seed -> Float
export floatFromSeed = pipe(
  LCG.next,
  LCG.unSeed,
  (x) => (x / LCG_M),
)

/**
 * Generate a random integer between two integer bounds
 * @since 0.0.1
 * @example
 * PRNG.randomInt(0, 100, PRNG.create(10))
 */
randomInt :: Integer -> Integer -> Seed -> Integer
export randomInt = (low, high, seed) => pipe(
  floatFromSeed,
  intGradient(low, high),
)(seed)

/**
 * Generate a random boolean
 * @since 0.0.1
 * @example
 * PRNG.randomBool(PRNG.create(10))
 */
randomBool :: Seed -> Boolean
export randomBool = pipe(
  floatFromSeed,
  (f) => f > 0.5,
)

/**
 * Pick a value from a list
 * @since 0.0.1
 * @example
 * PRNG.randomPick([0,1,2,3,4,5], PRNG.create(10))
 */
randomPick :: List a -> Seed -> Maybe a
export randomPick = (list, seed) => pipe(
  List.nth(randomInt(0, List.length(list) - 1, seed)),
)(list)

/**
 * Shuffle a given array
 * @since 0.0.1
 * @example
 * PRNG.randomShuffle(["ka", "dabra", "abra"], PRNG.create(10))
 */
randomShuffle :: List a -> Seed -> List a
export randomShuffle = (list, seed) => pipe(
  List.reduce(
    (agg, _) => {
      max = List.length(list) - 1
      x = randomInt(1, max, agg.current)
      next = LCG.next(agg.current)
      y = randomInt(1, max, next)
      fromStack = List.nth($, agg.stack)
      nthX = fromStack(x)
      nthY = fromStack(y)
      return {
        stack: pipe(
          maybeSetIndex(y, nthX),
          maybeSetIndex(x, nthY),
        )(agg.stack),
        current: next,
      }
    },
    { stack: list, current: seed },
  ),
  .stack,
)(list)
