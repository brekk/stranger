import type { Maybe } from "Maybe"

import type { Seed, SeededTuple } from "./Types"

import List from "List"
import Tuple from "Tuple"

import { LCG_A, LCG_C, LCG_M, SEED_MAX, SEED_MIN } from "./Constants"
import { maybeSetIndex } from "./List"
import { intGradient, modClamp, perturbation } from "./Logic"
import { Seed } from "./Types"



// This code partially based upon: https://github.com/purescript/purescript-lcg/blob/master/src/Random/LCG.purs
// which has a BSD-3 License - https://github.com/purescript/purescript-lcg/blob/master/LICENSE

/**
 * Make a Seed from an integer
 * @since 0.0.1
 * @example
 * Random.create(100)
 */
create :: Integer -> Seed
export create = pipe(
  modClamp(SEED_MIN, SEED_MAX),
  Seed,
)

/**
 * Pull the internal value from a Seed
 * @since 0.0.1
 * @example
 * Random.unSeed(Random.create(100))
 */
unSeed :: Seed -> Integer
export unSeed = where {
  Seed(x) =>
    x
}

/**
 * Transform a seed
 * @since 0.0.1
 * @example
 * Random.seedMap((x) => x * 2, Random.create(100))
 */
seedMap :: (Integer -> Integer) -> Seed -> Seed
export seedMap = (fn, seed) => pipe(
  unSeed,
  fn,
  Seed,
)(seed)

/**
 * Perturb a seed value to produce another internal generator value
 * @since 0.0.1
 * @example
 * Random.perturb(LCG_C, Random.create(100))
 */
perturb :: Integer -> Seed -> Seed
export perturb = (d, seed) => seedMap(perturbation($, LCG_A, d, LCG_M))(seed)


/**
 * Move the internal seed value forward by one perturbation
 * @since 0.0.1
 * @example
 * Random.step(Random.create(100))
 */
step :: Seed -> Seed
export step = perturb(LCG_C)




/**
 * Step a given PRNG multiple generations forward
 * @since 0.0.1
 * @example
 * pipe(
 *   PRNG.create,
 *   PRNG.stepN(10)
 * )(100)
 */
stepN :: Integer -> Seed -> Seed
export stepN = (steps, mSeed) => pipe(
  List.range(0),
  List.reduce((prev, _) => step(prev), mSeed),
)(steps)

/**
 * Simple wrapper function to create a SeededTuple
 * @since 0.0.1
 * @example
 * PRNG.seedTuple(Random.create(100), "hey there")
 */
seedTuple :: Seed -> a -> SeededTuple a
export seedTuple = (seed, a) => #[seed, a]

/**
 * Apply a transformation function to a given seed and set the step seed in a step
 * @since 0.0.1
 * @example
 * Random.mapStep(Random.randomBool, Random.create(100))
 */
mapStep :: (Seed -> a) -> Seed -> SeededTuple a
export mapStep = (fn, seed) => pipe(
  fn,
  seedTuple(step(seed)),
)(seed)

/**
 * Apply mapStep multiple times in a row
 * @since 0.0.1
 * @example
 * Random.mapSteps(10, Random.randomBool, Random.create(100))
 */
mapSteps :: Integer -> (Seed -> a) -> Seed -> List (SeededTuple a)
export mapSteps = (steps, fn, seed) => pipe(
  List.range(0),
  List.reduce(
    (agg, _) => pipe(
      mapStep(fn),
      where {
        #[newSeed, x] =>
          ({ prev: newSeed, stack: [...agg.stack, #[newSeed, x]] })
      },
    )(agg.prev),
    { stack: [], prev: seed },
  ),
  .stack,
)(steps + 1)

/**
 * Convert a list of SeededTuples into just a list
 * @since 0.0.1
 * @example
 * pipe(
 *   Random.create,
 *   Random.mapSteps(10, Random.randomBool),
 *   Random.dropSeeds
 * )(100)
 */
dropSeeds :: List (SeededTuple a) -> List a
export dropSeeds = (list) => map(Tuple.snd, list)

/**
 * Apply a transformation function to a seed multiple times and return the result
 * @since 0.0.1
 * pipe(
 *   Random.create,
 *   iterate(10, Random.randomFloat)
 * )(100
 */
iterate :: Integer -> (Seed -> a) -> Seed -> List a
export iterate = (steps, fn, seed) => pipe(
  mapSteps(steps, fn),
  dropSeeds,
)(seed)

/**
 * Get a floating value from a seed
 * @since 0.0.1
 * @example
 * Random.randomFloat(Random.create(100))
 */
randomFloat :: Seed -> Float
export randomFloat = pipe(
  step,
  unSeed,
  (x) => (x / LCG_M),
)

/**
 * Generate a random integer between two integer bounds
 * @since 0.0.1
 * @example
 * Random.randomInt(0, 100, Random.create(10))
 */
randomInt :: Integer -> Integer -> Seed -> Integer
export randomInt = (low, high, seed) => pipe(
  randomFloat,
  intGradient(low, high),
)(seed)

/**
 * Generate a random boolean
 * @since 0.0.1
 * @example
 * Random.randomBool(Random.create(10))
 */
randomBool :: Seed -> Boolean
export randomBool = pipe(
  randomFloat,
  (f) => f > 0.5,
)

/**
 * Pick a value from a list
 * @since 0.0.1
 * @example
 * Random.randomPick([0,1,2,3,4,5], Random.create(10))
 */
randomPick :: List a -> Seed -> Maybe a
export randomPick = (list, seed) => pipe(
  List.nth(randomInt(0, List.length(list) - 1, seed)),
)(list)

/**
 * Shuffle a given array
 * @since 0.0.1
 * @example
 * Random.randomShuffle(["ka", "dabra", "abra"], Random.create(10))
 */
randomShuffle :: List a -> Seed -> List a
export randomShuffle = (list, seed) => pipe(
  List.reduce(
    (agg, _) => {
      max = List.length(list) - 1
      x = randomInt(1, max, agg.current)
      current = step(agg.current)
      y = randomInt(1, max, current)
      fromStack = List.nth($, agg.stack)
      nthX = fromStack(x)
      nthY = fromStack(y)
      return {
        stack: pipe(
          maybeSetIndex(y, nthX),
          maybeSetIndex(x, nthY),
        )(agg.stack),
        current,
      }
    },
    { stack: list, current: seed },
  ),
  .stack,
)(list)

export alias BoundSeed = {
  bool :: {} -> Boolean,
  float :: {} -> Float,
  int :: Integer -> Integer -> Integer,
  pick :: List a -> Maybe a,
  shuffle :: List a -> List a,
}

generate :: Integer -> BoundSeed
export generate = (int) => {
  seed = create(int)
  return {
    int: randomInt($, $, seed),
    bool: () => randomBool(seed),
    shuffle: randomShuffle($, seed),
    float: () => randomFloat(seed),
    pick: randomPick($, seed),
  }
}
