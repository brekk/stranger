import type { Seed } from "./LCG"

import Tuple from "Tuple"
import List from "List"
import Math from "Math"
import { Just, Nothing } from "Maybe"
import Number from "Number"
import Wish from "Wish"

import LCG from "./LCG"



export alias NumberGenerator a = {} -> a
export alias SeedGenerator a = Seed -> NumberGenerator a
export alias Async a = Wish String a

create :: Integer -> Async Seed
export create = pipe(
  LCG.mkSeed,
  of,
)

step :: Async Seed -> Async Seed
export step = map(LCG.next)

stepN :: Integer -> Async Seed -> Async Seed
export stepN = (steps, mSeed) => pipe(
  List.range(0),
  List.reduce((prev, _) => step(prev), mSeed),
)(steps)

alias SeededTuple a = #[Seed, a]

seedTuple :: Seed -> a -> SeededTuple a
export seedTuple = (seed, a) => #[seed, a]

stepFn :: (Seed -> a) -> Seed -> SeededTuple a
export stepFn = (fn, seed) => #[LCG.next(seed), fn(seed)]

stepFnN :: Integer -> (Seed -> a) -> Async Seed -> Async (List (SeededTuple a))
export stepFnN = (steps, fn, mSeed) => map(
  (seed) => pipe(
    List.range(0),
    List.reduce(
      (agg, _) => pipe(
        stepFn(fn),
        where {
          #[newSeed, x] =>
            ({ prev: newSeed, stack: [...agg.stack, #[newSeed, x]] })
        },
      )(agg.prev),
      { stack: [], prev: seed },
    ),
    .stack,
  )(steps + 1),
  mSeed,
)

seededValues :: List (SeededTuple a) -> List a
export seededValues = map(Tuple.snd)

floatFromSeed :: Seed -> Float
export floatFromSeed = pipe(
  LCG.next,
  LCG.unSeed,
  (x) => (x / LCG.LCG_M),
)


boundIntFromSeed :: Integer -> Integer -> Float -> Integer
export boundIntFromSeed = (low, high, f) => pipe(
  Math.floor,
  Number.floatToInteger,
)(
  (Number.integerToFloat(high) - Number.integerToFloat(low) + 1.0)
    * f
    + Number.integerToFloat(low),
)

randomInt :: Integer -> Integer -> Seed -> Integer
export randomInt = (low, high, seed) => pipe(
  floatFromSeed,
  boundIntFromSeed(low, high)
)(seed)

